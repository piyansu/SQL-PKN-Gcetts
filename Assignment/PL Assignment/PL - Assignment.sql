--Assignment 1 =>
------------------------
--Q1:
DECLARE
N1 NUMBER(3); 
N2 NUMBER(3); 
N3 NUMBER(10); 
BEGIN
N1 := &N1 ;
N2 := &N2; 
N3 := N1 + N2 ; 
DBMS_OUTPUT.PUT_LINE('SUM = ' || N3) ; 
END;
/

--Q2:
DECLARE
N1 NUMBER(3); 
N2 NUMBER(3); 
BEGIN
N1 := &N1 ; 
N2 := &N2; 
IF N1>N2 THEN
    DBMS_OUTPUT.PUT_LINE(N1 || ' IS GREATER') ; 
ELSE 
    DBMS_OUTPUT.PUT_LINE(N2 || ' IS GREATER') ; 
END IF;

END;
/

--Q3:
DECLARE
  i NUMBER := 10; 
BEGIN
  WHILE i <= 50 LOOP
    DBMS_OUTPUT.PUT_LINE(i);
    i := i + 2;
  END LOOP;
END;
/

--Q4:
DECLARE
  n NUMBER := 10; 
  first_number NUMBER := 0;
  second_number NUMBER := 1;
  fibonacci NUMBER;
BEGIN
  DBMS_OUTPUT.PUT_LINE('First ' || n || ' Fibonacci numbers:');
  DBMS_OUTPUT.PUT_LINE(first_number);

  FOR i IN 2..n LOOP
    fibonacci := first_number + second_number;
    DBMS_OUTPUT.PUT_LINE(fibonacci);
    first_number := second_number;
    second_number := fibonacci;
  END LOOP;
END;
/

--Assignment 2 =>
------------------------

--Q1:
DECLARE 
V VARCHAR2(10) ;
V1 VARCHAR2(10) ;
L NUMBER(3);

BEGIN
V := '&V';
L := LENGTH(V);

FOR I IN REVERSE 1..L
LOOP
V1 := V1 || SUBSTR (V , I , 1);
END LOOP ; 

DBMS_OUTPUT.PUT_LINE(V1);

END;
/

--Q2:
DROP TABLE PRIME_ENTRY ; 

CREATE TABLE PRIME_ENTRY (
    PID NUMBER(3) PRIMARY KEY , 
    PNUM NUMBER(3)
);

DECLARE

NUM NUMBER(3);
R NUMBER(3) ;
F NUMBER(1) :=0 ; 
ID PRIME_ENTRY.PID % TYPE ; 

BEGIN

NUM := '&NUM';
FOR I IN 2..(NUM-1)
LOOP
    R := MOD (NUM , I);
    IF R = 0 THEN
        F:=1 ; 
        GOTO LBL1 ; 
    END IF ; 
END LOOP ; 

<<LBL1>>
IF F = 0 THEN 
    DBMS_OUTPUT.PUT_LINE('PRIME');
    SELECT MAX(PID) INTO ID FROM PRIME_ENTRY ; 
    IF ID IS NULL THEN 
        ID := 1 ;
    ELSE
        ID := ID+1 ;
    END IF ;

    INSERT INTO PRIME_ENTRY VALUES (ID , NUM); 
    DBMS_OUTPUT.PUT_LINE('DATA - INSERTED');

ELSE
    DBMS_OUTPUT.PUT_LINE('NOT - PRIME');
END IF ; 
END;
/


CREATE OR REPLACE FUNCTION FUN2 (A NUMBER) RETURN NUMBER
IS 

V PRIME_ENTRY.PID % TYPE ; 

BEGIN

SELECT PID INTO V FROM PRIME_ENTRY WHERE PNUM = A ; 
RETURN 1 ; 

EXCEPTION

WHEN NO_DATA_FOUND THEN
RETURN 0 ;

END;
/

DECLARE

X NUMBER(1) ; 

BEGIN

X := FUN2(5); 
DBMS_OUTPUT.PUT_LINE(X);

END; 
/

--Assignment 3 =>
------------------------

--Q1:
DECLARE 

    ACCID   ACCOUNT_23.ACNO%TYPE ; 
    AMT     ACCOUNT_23.AMOUNT%TYPE ;

BEGIN

    ACCID := &ACCID ; 
    INSERT INTO TRAN_ACC VALUES (ACCID  , 20000 , 'W' , SYSDATE);
    UPDATE ACCOUNT_23 SET AMOUNT = AMOUNT-20000 WHERE ACNO = ACCID ; 
    SAVEPOINT SVP1 ; 

    INSERT INTO TRAN_ACC VALUES (ACCID  , 15000 , 'W' , SYSDATE);
    UPDATE ACCOUNT_23 SET AMOUNT = AMOUNT-15000 WHERE ACNO = ACCID ; 
    SAVEPOINT SUP1 ;

    SELECT AMOUNT INTO AMT FROM ACCOUNT_23 WHERE ACNO = ACCID ; 

    IF AMT <5000 THEN 
        DBMS_OUTPUT.PUT_LINE('------Low Balance------');
        ROLLBACK TO SAVEPOINT SVP1 ; 
    END IF ; 
    COMMIT ; 

END;
/

--Q2:
DECLARE

BEGIN

    UPDATE ACCOUNT_23 SET LOCATION = 'SRM' WHERE ACNO = 555 ; 
    IF SQL%FOUND THEN
        DBMS_OUTPUT.PUT_LINE('FOUND') ;
    ELSE
        DBMS_OUTPUT.PUT_LINE('NOT-FOUND') ;
    END IF;

END;
/

--Q3:
DECLARE

    CURSOR PIYANSU IS SELECT ACNO , ACNAME FROM ACCOUNT_23 ; 

BEGIN
       
    FOR CRV IN PIYANSU
    LOOP 
        DBMS_OUTPUT.PUT_LINE(CRV.ACNO || CRV.ACNAME);
    END LOOP ; 

END;
/

--Q4:
DECLARE
    CURSOR CSECR (LC ACCOUNT_23.LOCATION%TYPE) IS SELECT ACNAME , AMOUNT FROM ACCOUNT_23 WHERE LOCATION = LC ;

    V1 ACCOUNT_23.ACNAME%TYPE ; 
    V2 ACCOUNT_23.AMOUNT%TYPE ; 
    LOC ACCOUNT_23.LOCATION%TYPE ; 

BEGIN
    LOC := '&LOC' ; 
    OPEN CSECR(LOC); 
    LOOP
        FETCH CSECR INTO V1 , V2 ; 
    EXIT WHEN CSECR%NOTFOUND ; 
        DBMS_OUTPUT.PUT_LINE(V1 || V2);
    END LOOP ;

    CLOSE CSECR ; 

END;
/

--Q5:
DECLARE
    CURSOR DCR IS SELECT DID , DNAME FROM DEPARTMENT_23 ; 
    CURSOR SCR (V1 DEPARTMENT_23.DID%TYPE) IS SELECT * FROM STUDENT_23 WHERE DID = V1 ;
    
BEGIN 

    FOR MVDEPT IN DCR 
    LOOP 
        FOR MVSTD IN SCR (MVDEPT.DID)
        LOOP            
        DBMS_OUTPUT.PUT_LINE(MVSTD.SID || MVSTD.SNAME);
        END LOOP ; 
    END LOOP ; 

END;
/

--Assignment 4 =>
------------------------

--Q1:

--Q2:
DECLARE

VAL NUMBER(3);
DIV_BY_ZERO  EXCEPTION ; 
PRAGMA    EXCEPTION_INIT ( DIV_BY_ZERO, -01476);

BEGIN 

VAL := 100/0 ; 
--ERROR NUMBER = ORA-01476
DBMS_OUTPUT.PUT_LINE(VAL);

EXCEPTION

WHEN DIV_BY_ZERO THEN 
DBMS_OUTPUT.PUT_LINE('-------Invalid--------');

END;
/

--Q3:
CREATE OR REPLACE TRIGGER TRG_ACC AFTER UPDATE OR DELETE ON ACCOUNT_23 FOR EACH ROW 

DECLARE

S VARCHAR(20);

BEGIN

IF UPDATING THEN 
    S:= 'UPDATE' ; 
    END IF ;
IF DELETING THEN
    S:= 'DELETE';
    END IF ;

INSERT INTO TRAN_ACC VALUES (:OLD.ACNO , :OLD.AMOUNT , S , SYSDATE);

END; 
/